# DBへの接続とレコードの管理、形式

このリポジトリでは、データの管理に常に `db/main.db` を使用しています。  
このDBはSQLite3によって作成されており、 `lib/DBAccess.py` 内で接続、各処理を行います。  

## DBAccess.pyの処理

DBAccess.pyではPHPのpdoのようにDBを扱うことができます。クエリの実行時およびインスタンスが解放される際にDBへの接続がコミットされます。  
関数 `exec(sql, paramtuple)` によってSQLを実行すると、結果を関数 `fetch(count=-1)` で取得できるようになります。  
fetchの引数countに-1を指定すると、exec関数で実行された結果を全て一度に受け取ることができます。  

## 各テーブルのカラムと用途

### errorTable

テーブル `errorTable` には、実行中に発生し、`ErrHandle`クラス経由で追加されたエラーが格納されます。カラムとその用途は以下のようになっています。

|id|errorTime|errorText|
|-|-|-|
|0(未使用)|エラー発生時刻|エラーメッセージ|

### userTable

テーブル `userTable` には、クローリング対象のアカウントの情報およびクローリング状態が格納されます。カラムとその用途は以下のようになっています。  

|id|TwitterID|modified|lastid|sinceid|
|-|-|-|-|-|
|状態|Twitter ID|最終更新日時|過去ツイ探索用起点|新規ツイ探索用起点|

カラム `状態` には、各ユーザのクローリング状態が格納されます。値と状態の対応は以下のようになっています。  

 * 0:ツイート探索起点未設定、追加直後
 * 1:ツイート探索起点設定完了、クローリング中
 * 2:過去ツイート探索終了、最新ツイート探索中

`lib/Clawler.py`では、状態値が0のものを優先的に処理し、なるべく全てのユーザを常に状態1または状態2にしておく様に動作します。  
カラム `過去ツイ・新規ツイ探索用起点` には、APIを使用してユーザタイムラインを取得するときの`since_id`、`max_id`が格納されており、次回クローリング処理実行時に使用、更新されます。  

### imageTable

テーブル `imageTable` には、収集対象の画像URLおよび保存先のローカルパス、画像とともにツイートされたテキストが格納されます。カラムとその用途は以下のようになっています。 

|id|TwitterID|post|content|imgPath|localPath|
|-|-|-|-|-|-|
|0(未使用)|Twitter ID|ツイート日時|ツイート文字列|画像URL|保存先ローカルパス|

カラム`localPath`の初期値は`Nodata`です(`Clawler.py`内で定義)。`Saver.py`内の関数`save`に各レコードのタプルリストを渡すと、3秒間隔(`Saver.py`内で定義)で画像を保存し、カラム`localPath`の値を更新します。  

**重要** 現行バージョンでは、カラム`localPath`の値が正しくないものになっています。この修正には`Saver.py`含め大規模なスクリプトの改修が必要になることが想定されるため、現行の修正予定はありません。  